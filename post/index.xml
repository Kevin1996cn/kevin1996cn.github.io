<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on I am thinking ...</title>
    <link>https://kevin1996cn.github.io/post/</link>
    <description>Recent content in Posts on I am thinking ...</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <copyright>All rights reserved - 2020</copyright>
    <lastBuildDate>Fri, 03 Apr 2020 17:32:16 +0800</lastBuildDate>
    
	<atom:link href="https://kevin1996cn.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>15.三数之和</title>
      <link>https://kevin1996cn.github.io/2020/04/03/15.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</link>
      <pubDate>Fri, 03 Apr 2020 17:32:16 +0800</pubDate>
      
      <guid>https://kevin1996cn.github.io/2020/04/03/15.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</guid>
      <description>&lt;p&gt;题意：找三个数，使其和为0，给的数组中有重复值，不能重复拿某个值。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>18.四数之和</title>
      <link>https://kevin1996cn.github.io/2020/04/03/18.%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C/</link>
      <pubDate>Fri, 03 Apr 2020 17:32:16 +0800</pubDate>
      
      <guid>https://kevin1996cn.github.io/2020/04/03/18.%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C/</guid>
      <description>&lt;p&gt;题意：找四个数看能否等于target&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>43. 字符串相乘</title>
      <link>https://kevin1996cn.github.io/2020/04/03/43.-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E4%B9%98/</link>
      <pubDate>Fri, 03 Apr 2020 17:32:16 +0800</pubDate>
      
      <guid>https://kevin1996cn.github.io/2020/04/03/43.-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E4%B9%98/</guid>
      <description>&lt;p&gt;题意：大数相乘，给的字符串&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>C&#43;&#43;刷题相关知识点</title>
      <link>https://kevin1996cn.github.io/2020/04/03/c-%E5%88%B7%E9%A2%98%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9/</link>
      <pubDate>Fri, 03 Apr 2020 17:32:16 +0800</pubDate>
      
      <guid>https://kevin1996cn.github.io/2020/04/03/c-%E5%88%B7%E9%A2%98%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9/</guid>
      <description>&lt;p&gt;一些C++ STL的使用，和一些刷题需要注意的问题，例如数据范围、初始化、全排列、报错等。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>DP</title>
      <link>https://kevin1996cn.github.io/2020/04/03/dp/</link>
      <pubDate>Fri, 03 Apr 2020 17:32:16 +0800</pubDate>
      
      <guid>https://kevin1996cn.github.io/2020/04/03/dp/</guid>
      <description>&lt;p&gt;一些动态规划的例题。&lt;/p&gt;
&lt;p&gt;Leetcode 392、714、1143、279、120、300、70、121、486&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>二分</title>
      <link>https://kevin1996cn.github.io/2020/04/03/%E4%BA%8C%E5%88%86/</link>
      <pubDate>Fri, 03 Apr 2020 17:32:16 +0800</pubDate>
      
      <guid>https://kevin1996cn.github.io/2020/04/03/%E4%BA%8C%E5%88%86/</guid>
      <description>&lt;p&gt;一些涉及二分的例题。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>位运算、异或</title>
      <link>https://kevin1996cn.github.io/2020/04/03/%E4%BD%8D%E8%BF%90%E7%AE%97%E5%BC%82%E6%88%96/</link>
      <pubDate>Fri, 03 Apr 2020 17:32:16 +0800</pubDate>
      
      <guid>https://kevin1996cn.github.io/2020/04/03/%E4%BD%8D%E8%BF%90%E7%AE%97%E5%BC%82%E6%88%96/</guid>
      <description>&lt;p&gt;一些涉及位运算、异或性质和操作的知识点及例题。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>剑指offer-64.求1&#43;2&#43;...&#43;n</title>
      <link>https://kevin1996cn.github.io/2020/04/03/%E5%89%91%E6%8C%87offer-64.%E6%B1%821-2-...-n/</link>
      <pubDate>Fri, 03 Apr 2020 17:32:16 +0800</pubDate>
      
      <guid>https://kevin1996cn.github.io/2020/04/03/%E5%89%91%E6%8C%87offer-64.%E6%B1%821-2-...-n/</guid>
      <description>&lt;p&gt;一些C++ STL的使用，和一些刷题需要注意的问题，例如数据范围、初始化、全排列、报错等。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>回溯</title>
      <link>https://kevin1996cn.github.io/2020/04/03/%E5%9B%9E%E6%BA%AF/</link>
      <pubDate>Fri, 03 Apr 2020 17:32:16 +0800</pubDate>
      
      <guid>https://kevin1996cn.github.io/2020/04/03/%E5%9B%9E%E6%BA%AF/</guid>
      <description>&lt;p&gt;一些涉及回溯的例题。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>图论</title>
      <link>https://kevin1996cn.github.io/2020/04/03/%E5%9B%BE%E8%AE%BA/</link>
      <pubDate>Fri, 03 Apr 2020 17:32:16 +0800</pubDate>
      
      <guid>https://kevin1996cn.github.io/2020/04/03/%E5%9B%BE%E8%AE%BA/</guid>
      <description>&lt;p&gt;一些涉及图论算法的习题，包含floyd、djistra等。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>字符串</title>
      <link>https://kevin1996cn.github.io/2020/04/03/%E5%AD%97%E7%AC%A6%E4%B8%B2/</link>
      <pubDate>Fri, 03 Apr 2020 17:32:16 +0800</pubDate>
      
      <guid>https://kevin1996cn.github.io/2020/04/03/%E5%AD%97%E7%AC%A6%E4%B8%B2/</guid>
      <description>&lt;p&gt;一些涉及字符串相关的知识点及操作的例题。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title></title>
      <link>https://kevin1996cn.github.io/1/01/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kevin1996cn.github.io/1/01/01/</guid>
      <description>**题意：**把最外面一层的括号去掉。
示例 1：
输入：&amp;quot;(()())(())&amp;quot; 输出：&amp;quot;()()()&amp;quot; 解释： 输入字符串为 &amp;quot;(()())(())&amp;quot;，原语化分解得到 &amp;quot;(()())&amp;quot; + &amp;quot;(())&amp;quot;， 删除每个部分中的最外层括号后得到 &amp;quot;()()&amp;quot; + &amp;quot;()&amp;quot; = &amp;quot;()()()&amp;quot;。 示例 2：
输入：&amp;quot;(()())(())(()(()))&amp;quot; 输出：&amp;quot;()()()()(())&amp;quot; 解释： 输入字符串为 &amp;quot;(()())(())(()(()))&amp;quot;，原语化分解得到 &amp;quot;(()())&amp;quot; + &amp;quot;(())&amp;quot; + &amp;quot;(()(()))&amp;quot;， 删除每隔部分中的最外层括号后得到 &amp;quot;()()&amp;quot; + &amp;quot;()&amp;quot; + &amp;quot;()(())&amp;quot; = &amp;quot;()()()()(())&amp;quot;。 示例 3：
输入：&amp;quot;()()&amp;quot; 输出：&amp;quot;&amp;quot; 解释： 输入字符串为 &amp;quot;()()&amp;quot;，原语化分解得到 &amp;quot;()&amp;quot; + &amp;quot;()&amp;quot;， 删除每个部分中的最外层括号后得到 &amp;quot;&amp;quot; + &amp;quot;&amp;quot; = &amp;quot;&amp;quot;。 AC：
class Solution { public: string removeOuterParentheses(string S) { string res=&amp;#34;&amp;#34;; int flag=1; for(int i=1;i&amp;lt;S.size();i++) { if(S[i]==&amp;#39;(&amp;#39;) flag++; else if(S[i]==&amp;#39;)&amp;#39;) flag--; if(flag!</description>
    </item>
    
    <item>
      <title></title>
      <link>https://kevin1996cn.github.io/1/01/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kevin1996cn.github.io/1/01/01/</guid>
      <description>题意：找到给定数字距离最近的所有组成数字为偶数的那个数。输出这俩数的差值。
如2018距离最近的全是偶数的是2020，故输出2.
启示：这种题能想到算一遍加的算一遍减的。也应该可以</description>
    </item>
    
    <item>
      <title></title>
      <link>https://kevin1996cn.github.io/1/01/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kevin1996cn.github.io/1/01/01/</guid>
      <description>**
题意**：给一个二叉树，找到给出两个节点的最近父节点。（**一个节点也可以是它自己的祖先**）
示例 1:
输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1 输出: 3 解释: 节点 5 和节点 1 的最近公共祖先是节点 3。 示例 2:
输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4 输出: 5 解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。 AC:
/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) { //当前节点是null即找到叶子也没有就返回null  //如果找到这俩节点就返回这俩节点  if (!</description>
    </item>
    
    <item>
      <title></title>
      <link>https://kevin1996cn.github.io/1/01/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kevin1996cn.github.io/1/01/01/</guid>
      <description>题意：删除单链表中指定值的节点
示例 1:
输入: head = [4,5,1,9], node = 5 输出: [4,1,9] 解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&amp;gt; 1 -&amp;gt; 9. 示例 2:
输入: head = [4,5,1,9], node = 1 输出: [4,5,9] 解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&amp;gt; 5 -&amp;gt; 9. AC:
/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: void deleteNode(ListNode* node) { //这题和正常思维不一样，node这个节点就是需要删除的节点；  node-&amp;gt;val=node-&amp;gt;next-&amp;gt;val; //把删除节点的下一个值给这个节点  //ListNode* temp=node-&amp;gt;next; //建立一个新节点指向下一个  node-&amp;gt;next=node-&amp;gt;next-&amp;gt;next; //让被删除的节点指向  //delete temp;  } }; 不要想错了，是让你删除当前节点，不是当前节点的下一个。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://kevin1996cn.github.io/1/01/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kevin1996cn.github.io/1/01/01/</guid>
      <description>题意：给的是好多数对，第一个代表身高，第二个代表在它前面有多少比他高的。
示例
输入: [[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]] 输出: [[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]] 第三个【5，2】在它前面有两个比他高的
AC：
bool mysort(const vector&amp;lt;int&amp;gt;&amp;amp;a , const vector&amp;lt;int&amp;gt;&amp;amp;b){ return a[0]&amp;gt;b[0]||a[0]==b[0]&amp;amp;&amp;amp;a[1]&amp;lt;b[1]; } class Solution { public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; reconstructQueue(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; people) { sort(people.begin(),people.end(),mysort); //自定义排序  //注意到compare函数写在类外，这是因为  //std::sort要求函数对象，或是静态/全局函数指针，非静态成员函数指针不能直接传递给std::sort  vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; ans; for(auto v:people) ans.insert(ans.begin()+v[1],v); //插入：位置，值  return ans; } }; 其中sort的排序函数可以缩写到一起
sort(people.begin(),people.end(),[](const vector&amp;lt;int&amp;gt;&amp;amp;a,const vector&amp;lt;int&amp;gt;&amp;amp;b) { return a[0]&amp;gt;b[0] || a[0]==b[0]&amp;amp;&amp;amp;a[1]&amp;lt;b[1];}); 本题，就是先排序，按身高从大到小，第二个值从小到大，然后一个一个插入begin+第二个值的位置。
很神奇，就是这么做，但是貌似不好想。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://kevin1996cn.github.io/1/01/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kevin1996cn.github.io/1/01/01/</guid>
      <description>旋转图像  题意：给你一个二维数组，给他顺时针旋转90度。
分析：给两重循环，外层控制进入第几层。
​	内层控制向左向右向上向下移动的位置。
AC:
class Solution { public: void rotate(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; matrix) { int n=matrix.size()-1; //n=维数-1  int layers; if((n+1)%2==0) layers=(n+1)/2; else layers=n/2; cout&amp;lt;&amp;lt;&amp;#34;cengshu:&amp;#34;&amp;lt;&amp;lt;layers&amp;lt;&amp;lt;endl; for(int start=0;start&amp;lt;layers;start++) { for(int i=0;i&amp;lt;=n-1-start*2;i++) //  { int tmp=matrix[n-start-i][start]; //cout&amp;lt;&amp;lt;matrix[n-start-i][start]&amp;lt;&amp;lt;&amp;#34;=&amp;#34;&amp;lt;&amp;lt;matrix[n-start][n-start-i]&amp;lt;&amp;lt;endl;  matrix[n-start-i][start]=matrix[n-start][n-start-i]; //cout&amp;lt;&amp;lt;matrix[n-start][n-start-i]&amp;lt;&amp;lt;&amp;#34;=&amp;#34;&amp;lt;&amp;lt;matrix[start+i][n-start]&amp;lt;&amp;lt;endl;  matrix[n-start][n-start-i]=matrix[start+i][n-start]; //cout&amp;lt;&amp;lt;matrix[start+i][n-start]&amp;lt;&amp;lt;&amp;#34;=&amp;#34;&amp;lt;&amp;lt;matrix[start][start+i]&amp;lt;&amp;lt;endl;  matrix[start+i][n-start]=matrix[start][start+i]; //cout&amp;lt;&amp;lt;matrix[start][start+i]&amp;lt;&amp;lt;&amp;#34;=&amp;#34;&amp;lt;&amp;lt;tmp&amp;lt;&amp;lt;endl;  matrix[start][start+i]=tmp; } } } }; </description>
    </item>
    
    <item>
      <title></title>
      <link>https://kevin1996cn.github.io/1/01/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kevin1996cn.github.io/1/01/01/</guid>
      <description>快速幂
AC:
class Solution { public: double myPow(double x, int n) { if (n == 0) { return 1; } if (n == 1) { return x; } if (n == -1) { return 1 / x; } double half = myPow(x, n / 2); double rest = myPow(x, n % 2); return rest * half * half; } }; </description>
    </item>
    
    <item>
      <title></title>
      <link>https://kevin1996cn.github.io/1/01/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kevin1996cn.github.io/1/01/01/</guid>
      <description>**题意：**把字符串中所有大写字母改成小写字母。
示例 1：
输入: &amp;quot;Hello&amp;quot; 输出: &amp;quot;hello&amp;quot; 示例 2：
输入: &amp;quot;here&amp;quot; 输出: &amp;quot;here&amp;quot; 示例 3：
输入: &amp;quot;LOVELY&amp;quot; 输出: &amp;quot;lovely&amp;quot; AC：
class Solution { public: string toLowerCase(string str) { string str1=str; for(int i=0;i&amp;lt;str.size();i++) { if(str[i]&amp;gt;=&amp;#39;A&amp;#39;&amp;amp;&amp;amp;str[i]&amp;lt;=&amp;#39;Z&amp;#39;) { str1[i]=str[i]+32; //大写字母ASCII码小，大小写差32。 	} else {	str1[i]=str[i]; } } return str1; } }; </description>
    </item>
    
    <item>
      <title></title>
      <link>https://kevin1996cn.github.io/1/01/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kevin1996cn.github.io/1/01/01/</guid>
      <description>**题意：**J中a和A代表宝石类型，找出S中有多少宝石。
示例 1:
输入: J = &amp;quot;aA&amp;quot;, S = &amp;quot;aAAbbbb&amp;quot; 输出: 3 示例 2:
输入: J = &amp;quot;z&amp;quot;, S = &amp;quot;ZZ&amp;quot; 输出: 0 AC：
class Solution { public: int numJewelsInStones(string J, string S) { int a=&amp;#39;a&amp;#39;,z=&amp;#39;z&amp;#39;,A=&amp;#39;A&amp;#39;,Z=&amp;#39;Z&amp;#39;; int daxie[26]={0}; int xiaoxie[26]={0}; int res=0; for(int i=0;i&amp;lt;J.size();i++) { int t=J[i]; if(t&amp;gt;=&amp;#39;a&amp;#39;&amp;amp;&amp;amp;t&amp;lt;=&amp;#39;z&amp;#39;) { xiaoxie[t-&amp;#39;a&amp;#39;]++; } else { daxie[t-&amp;#39;A&amp;#39;]++; } } for(int j=0;j&amp;lt;S.size();j++) { int t=S[j]; if(t&amp;gt;=&amp;#39;a&amp;#39;&amp;amp;&amp;amp;t&amp;lt;=&amp;#39;z&amp;#39;) { if(xiaoxie[t-&amp;#39;a&amp;#39;]) res++; } else { if(daxie[t-&amp;#39;A&amp;#39;]) res++; } } return res; } }; </description>
    </item>
    
    <item>
      <title></title>
      <link>https://kevin1996cn.github.io/1/01/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kevin1996cn.github.io/1/01/01/</guid>
      <description>题意：给定一个二进制矩阵 A，我们想先水平翻转图像，然后反转图像并返回结果。
水平翻转图片就是将图片的每一行都进行翻转，即逆序（镜像）。例如，水平翻转 [1, 1, 0] 的结果是 [0, 1, 1]。
反转图片的意思是图片中的 0 全部被 1 替换， 1 全部被 0 替换。例如，反转 [0, 1, 1] 的结果是 [1, 0, 0]。
示例 1:
输入: [[1,1,0],[1,0,1],[0,0,0]] 输出: [[1,0,0],[0,1,0],[1,1,1]]、 解释: 首先翻转每一行: [[0,1,1],[1,0,1],[0,0,0]]； 然后反转图片: [[1,0,0],[0,1,0],[1,1,1]] 示例 2:
输入: [[1,1,0,0],[1,0,0,1],[0,1,1,1],[1,0,1,0]] 输出: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]] 解释: 首先翻转每一行: [[0,0,1,1],[1,0,0,1],[1,1,1,0],[0,1,0,1]]； 然后反转图片: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]] AC：
class Solution { public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; flipAndInvertImage(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; A) { int len1=A.size(); for(int i=0;i&amp;lt;len1;i++) { int len2=A[i].size(); for(int j=0;j&amp;lt;len2;j++) { if(A[i][j]==0) A[i][j]=1; else A[i][j]=0; } for(int j=0;j&amp;lt;len2/2;j++) { int t=A[i][j]; A[i][j]=A[i][len2-1-j]; A[i][len2-1-j]=t; } } return A; } }; </description>
    </item>
    
    <item>
      <title></title>
      <link>https://kevin1996cn.github.io/1/01/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kevin1996cn.github.io/1/01/01/</guid>
      <description>**题意：给定一个带有头结点 head 的非空单链表，返回链表的中间结点。如果有两个中间结点，则返回第二个中间结点。
示例 1：
输入：[1,2,3,4,5] 输出：此列表中的结点 3 (序列化形式：[3,4,5]) 返回的结点值为 3 。 (测评系统对该结点序列化表述是 [3,4,5])。 注意，我们返回了一个 ListNode 类型的对象 ans，这样： ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, 以及 ans.next.next.next = NULL. 示例 2：
输入：[1,2,3,4,5,6] 输出：此列表中的结点 4 (序列化形式：[4,5,6]) 由于该列表有两个中间结点，值分别为 3 和 4，我们返回第二个结点。 思路：利用快慢指针的思想，快指针的每次走两个，慢指针一次走一个，快指针到头了，慢指针正好走一半。
AC：
/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode* middleNode(ListNode* head) { ListNode* slow=head; ListNode* fast=head; while(fast&amp;amp;&amp;amp;fast-&amp;gt;next!</description>
    </item>
    
    <item>
      <title></title>
      <link>https://kevin1996cn.github.io/1/01/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kevin1996cn.github.io/1/01/01/</guid>
      <description>**题意：给一个二叉搜索树（排序树），返回LR之间的值的和。
示例 1：
输入：root = [10,5,15,3,7,null,18], L = 7, R = 15 输出：32 示例 2：
输入：root = [10,5,15,3,7,13,18,1,null,6], L = 6, R = 10 输出：23 AC：
/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: int rangeSumBST(TreeNode* root, int L, int R) { if(root==NULL) return 0; if(root-&amp;gt;val&amp;gt;=L&amp;amp;&amp;amp;root-&amp;gt;val&amp;lt;=R) //当前节点在LR中间，就返回这个的值+递归左右。  { return root-&amp;gt;val + rangeSumBST(root-&amp;gt;left,L,R) + rangeSumBST(root-&amp;gt;right,L,R); } else if(root-&amp;gt;val&amp;lt;L) //比L小，去右边，因为是排序树  { return rangeSumBST(root-&amp;gt;right,L,R); } else return rangeSumBST(root-&amp;gt;left,L,R); } }; </description>
    </item>
    
  </channel>
</rss>